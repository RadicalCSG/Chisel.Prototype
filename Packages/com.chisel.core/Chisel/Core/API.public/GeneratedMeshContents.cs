using System;
using Unity.Collections;
using Unity.Mathematics;

namespace Chisel.Core
{
    /// <summary>Stores a mesh generated by calling <see cref="Chisel.Core.CSGTree.GetGeneratedMesh" />.</summary>
    /// <remarks>See the [Create Unity Meshes](~/documentation/createUnityMesh.md) article for more information. <see cref="Chisel.Core.GeneratedMeshContents"/> holds the binary mesh data from the managed side and can be turned into a [UnityEngine.Mesh](https://docs.unity3d.com/ScriptReference/Mesh.html) by calling <see cref="Chisel.Core.GeneratedMeshContents.CopyTo" />.
    /// See the [Create Unity Meshes](~/documentation/createUnityMesh.md) article for more information.</remarks>
    /// <seealso cref="Chisel.Core.CSGTree" /><seealso cref="Chisel.Core.CSGTree.GetGeneratedMesh" />
    /// <seealso cref="Chisel.Core.GeneratedMeshDescription"/><seealso cref="Chisel.Core.SurfaceDescription"/>
    /// <seealso href="https://docs.unity3d.com/ScriptReference/Mesh.html">UnityEngine.Mesh</seealso>
    public sealed class GeneratedMeshContents : IDisposable
    {
        /// <value>Describes the GeneratedMesh.</value>
        /// <remarks>This is a copy of the description used to retrieve the GeneratedMeshContents by calling <see cref="Chisel.Core.CSGTree.GetGeneratedMesh" />.</remarks>
        public GeneratedMeshDescription description;

        /// <value>Triplet indices to the vertices that make up the triangles in this mesh.</value>
        public NativeArray<int> 		indices;

        /// <value>A brush index per triangle.</value>
        public NativeArray<int> 		brushIndices;
        
        /// <value>Position for each vertex.</value>
        public NativeArray<float3>	    positions;
        
        /// <value>Tangent for each vertex.</value>
        /// <remarks><note>Can be null when the <see cref="description"/> has no tangents set in its <see cref="Chisel.Core.MeshQuery.UsedVertexChannels"/>.</note></remarks>
        public NativeArray<float4>      tangents;
        
        /// <value>Normal for each vertex.</value>
        /// <remarks>Each <seealso cref="Chisel.Core.BrushMesh.Polygon"/> has a <seealso cref="Chisel.Core.SurfaceDescription.smoothingGroup"/> field in its <seealso cref="Chisel.Core.SurfaceDescription"/>.
        /// If the <seealso cref="Chisel.Core.SurfaceDescription.smoothingGroup"/> is set to something other than 0 the normal is calculated by; combining the normals of all the surfaces around each vertex that share the same <seealso cref="Chisel.Core.SurfaceDescription.smoothingGroup"/>.
        /// If the <seealso cref="Chisel.Core.SurfaceDescription.smoothingGroup"/> is set to 0 the normal of the polygon is used.
        /// <note>Can be null when the <see cref="description"/>  has no normals set in its <see cref="Chisel.Core.MeshQuery.UsedVertexChannels"/>.</note>
        /// </remarks>
        public NativeArray<float3>      normals;

        /// <value>First uv channel for each vertex.</value>
        /// <remarks>These are created by multiplying the vertices of the <seealso cref="Chisel.Core.BrushMesh"/>, which was used to generate this geometry, 
        /// by the <seealso cref="Chisel.Core.SurfaceDescription.UV0" /> <seealso cref="Chisel.Core.UVMatrix"/> of the <seealso cref="Chisel.Core.SurfaceDescription"/> of the vertex.
        /// <note>Can be null when the <see cref="description"/> has no <seealso cref="Chisel.Core.VertexChannelFlags.UV0" /> set in its <see cref="Chisel.Core.MeshQuery.UsedVertexChannels"/>.</note>
        /// </remarks>
        public NativeArray<float2>      uv0;

        /// <value>Bounds of the mesh.</value>
        public UnityEngine.Bounds       bounds;

        /// <summary>Copies the contents of the generated mesh to a [UnityEngine.Mesh](https://docs.unity3d.com/ScriptReference/Mesh.html).</summary>
        /// <param name="mesh">The mesh to copy the <see cref="Chisel.Core.GeneratedMeshContents"/> into</param>
        /// <remarks><code>
        /// MeshDescription meshDescription = ... ;
        /// GeneratedMeshContents contents = tree.GetGeneratedMesh(meshDescription);
        /// UnityEngine.Mesh unityMesh = new UnityEngine.Mesh();
        /// contents.CopyTo(unityMesh);
        /// </code>
        /// See the [Create Unity Meshes](~/documentation/createUnityMesh.md) article for more information.
        /// </remarks>
        /// <exception cref="System.ArgumentNullException">Thrown when <paramref name="mesh"/> is null.</exception>
        /// <exception cref="System.ArgumentException">Thrown when <paramref name="mesh"/> is invalid. This can happen when the mesh has already been destroyed.</exception>
        public void CopyTo(UnityEngine.Mesh mesh)
        { 
            if (object.ReferenceEquals(mesh, null))
                throw new ArgumentNullException("mesh");
            if (!mesh)
                throw new ArgumentException("mesh", "mesh is not valid, it might have already been destroyed");

            if (description.vertexCount < 3 ||
                description.indexCount < 3)
            {
                mesh.Clear();
                return;
            }
            
            mesh.SetVertices(positions);
            if (normals  .IsCreated) mesh.SetNormals(normals);
            if (tangents .IsCreated) mesh.SetTangents(tangents);
            if (uv0      .IsCreated) mesh.SetUVs(0, uv0);
            
            mesh.SetTriangles(indices.ToArray(), 0, false);
            mesh.bounds = bounds; 
        }

        public void Dispose()
        {
            if (indices     .IsCreated) indices.Dispose();
            if (brushIndices.IsCreated) brushIndices.Dispose();
            if (positions   .IsCreated) positions.Dispose();
            if (tangents    .IsCreated) tangents.Dispose();
            if (normals     .IsCreated) normals.Dispose();
            if (uv0         .IsCreated) uv0.Dispose();
            
            indices      = default;
            brushIndices = default;
            positions    = default;
            tangents     = default;
            normals      = default;
            uv0          = default;
        }
    };
}